Give the context that everything that will be presented will be about what my goals are, what I have done so far, and what I need to do in the future to achieve my goals

To explain the problem, let me first give a 30 second explaination of what Hari's pipeline does.
- Aims to ensure that the eBPF verifier's abstract states are accurate
- Does this by producing a logical encoding of the abstract operators from the verifier source code. It will then then check the soundness by trying to produce abstract and concrete states such that when the concrete and abstract functions are performed, the conrete state is not in the abstract state.

Problem: We want a way to make sure that the SMT encoding of the abstract operators themselves have the same behaviour as the verifier.

Goal is to check that the behaviour of the SMT encodings matches the behaviour of the verifier code. Based on the output of the abstract operators in the SMT code we can decide if a jump is out of bounds or malformed for example. We can compare the SMT determination of the program's validity with the verifier's. If the SMT encoding provides a false positive, then we know there is an issue with the logical encoding.

Load the logic solver with the SMT encoding for a particular instruction and some abstract states and arguments for the instruction. Then see what the results are. Attempt to get the real verifier to these same abstract states and then run the instruction whose encoding is being tested. See if the verifier and the SMT encoding produce the same outcome.

What is complete:
- We can produce registers with states that are fully unknown or fully known 
- We can insert an instruction afterwards
- We can get the verifier output

What we need to add (short-term):
- A way to load in an SMT encoding of an abstract operator, 
- A method to input the same state and instruction into the encoding test and verifier test
- A way to get the output from both and compare them

